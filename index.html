<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Army Skirmish â€” Touch RTS</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0e16;color:#e6e8ef;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #ui{position:fixed;left:0;right:0;top:0;padding:8px 12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
        background:linear-gradient(180deg,rgba(11,14,22,.9),rgba(11,14,22,0));font-size:14px;z-index:4}
    .pill{background:#121827;border:1px solid #1e2639;padding:6px 10px;border-radius:999px}
    #wrap{height:100%;display:grid;place-items:center}
    canvas#c{touch-action:none;border:1px solid #1e2639;border-radius:12px;background:#0f1424;
           box-shadow:0 10px 30px rgba(0,0,0,.35)}
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(5,8,16,.65);z-index:6}
    #panel{background:#0f1424;border:1px solid #1e2639;padding:24px;border-radius:16px;text-align:center;max-width:520px}
    button{background:#1b2a4a;border:1px solid #2a3b65;color:#e6e8ef;padding:10px 14px;border-radius:10px;cursor:pointer}
    #btns{display:flex;gap:8px}
    input[type=file]{display:none}
    .spacer{flex:1 1 0}
    #audioControls{display:flex;gap:6px;align-items:center}
    #volumeSlider{width:80px}

    /* Selection HUD */
    #selHUD{
      position:fixed;left:12px;top:64px;z-index:3;
      background:#0f1424;border:1px solid #1e2639;border-radius:12px;
      padding:10px; min-width:180px; max-width:260px;
      box-shadow:0 8px 22px rgba(0,0,0,.35)
    }
    #selHUD h4{margin:0 0 8px 0;font-size:12px;color:#aab4d0;display:flex;justify-content:space-between;gap:8px}
    #selHUD .grid{display:grid;grid-template-columns:repeat(6,1fr);gap:6px}
    .tile{position:relative;height:24px;border-radius:6px;border:1px solid #243151;background:#18223a;display:flex;align-items:center;justify-content:center;font-size:11px;color:#dce6ff}
    .tile.rifle{background:#294160;border-color:#345180}
    .tile.gren{background:#6b3d1f;border-color:#8a5a2e}
    .hpbar{position:absolute;left:2px;right:2px;bottom:2px;height:3px;background:#0b1120;border-radius:3px;overflow:hidden}
    .hpbar>span{display:block;height:100%;background:#36d399}
    #orderFlash{margin-top:6px;font-size:11px;color:#cfe8ff;opacity:0;transition:opacity .25s ease}
    #orderFlash.show{opacity:1}

    /* Minimap */
    #minimapWrap{
      position:fixed;right:12px;top:64px;z-index:3;
      background:#0f1424;border:1px solid #1e2639;border-radius:12px;
      padding:8px;box-shadow:0 8px 22px rgba(0,0,0,.35)
    }
    #minimap{display:block;border-radius:8px;border:1px solid #1e2639;background:#192233}
    #miniLabel{font-size:12px;color:#aab4d0;margin-bottom:6px}

    /* Help modal */
    #helpModal{
      position:fixed; inset:0; display:none; z-index:7;
      align-items:center; justify-content:center;
      background:rgba(5,8,16,.65);
    }
    #helpCard{
      background:#0f1424;border:1px solid #1e2639;border-radius:16px;
      padding:20px; max-width:680px; color:#e6e8ef;
      box-shadow:0 20px 50px rgba(0,0,0,.45)
    }
    #helpCard h2{margin:0 0 8px 0}
    #helpCard .grid{display:grid;grid-template-columns:repeat(2,minmax(240px,1fr));gap:10px}
    #helpCard kbd{background:#121827;border:1px solid #1e2639;border-bottom-color:#121a2d;
      padding:2px 6px;border-radius:6px;font-size:12px}
    #helpCard ul{margin:8px 0 0 18px}
    #helpBtn{font-weight:700}
  </style>
</head>
<body>
  <!-- TOP TOOLBAR -->
  <div id="ui">
    <div id="btns">
      <button id="buildRifleman">Build Rifleman (50)</button>
      <button id="buildGrenadier">Build Grenadier (100)</button>
      <button id="selectAll">Select all</button>
      <button id="restart">Restart</button>
      <button id="terrainBtn">Use image terrain</button>
      <input id="terrainFile" type="file" accept="image/*" />
      <button id="helpBtn">?</button>
    </div>
    <div class="spacer"></div>
    <div id="audioControls">
      <button id="muteBtn">ðŸ”Š</button>
      <input id="volumeSlider" type="range" min="0" max="1" step="0.05" value="0.25" />
    </div>
    <div class="pill"><b>Army Skirmish</b> â€” click ground to move (green), enemy to attack (red)</div>
    <div class="pill">Large map â€¢ Minimap click-to-pan â€¢ Fog of War</div>
  </div>

  <!-- Selection HUD -->
  <div id="selHUD">
    <h4><span>Selected</span><span id="selCount">0</span></h4>
    <div class="grid" id="selGrid"></div>
    <div id="orderFlash">Order: Move</div>
  </div>

  <!-- Minimap -->
  <div id="minimapWrap">
    <div id="miniLabel">Minimap (click to pan)</div>
    <canvas id="minimap" width="200" height="125"></canvas>
  </div>

  <!-- Help Modal -->
  <div id="helpModal">
    <div id="helpCard">
      <h2>How to Play</h2>
      <div class="grid">
        <div>
          <h3>Basic</h3>
          <ul>
            <li>Drag on the map to <b>box select</b> units.</li>
            <li>Click ground to <b>move</b> (green target).</li>
            <li>Click enemy to <b>attack</b> (red target).</li>
            <li>Use the <b>minimap</b> (top-right) to jump view.</li>
          </ul>
        </div>
        <div>
          <h3>Camera</h3>
          <ul>
            <li><kbd>WASD</kbd> / <kbd>Arrow Keys</kbd> to pan (hold <kbd>Shift</kbd> for faster).</li>
            <li><kbd>Space</kbd> + <b>Left Drag</b> or <b>Middle-Mouse Drag</b> to pan.</li>
            <li>Move mouse near canvas edge to <b>edge-scroll</b>.</li>
            <li><b>Mouse wheel</b> pans vertically.</li>
          </ul>
        </div>
        <div>
          <h3>Units</h3>
          <ul>
            <li><b>Rifleman</b>: mid-range direct fire.</li>
            <li><b>Grenadier</b>: long-range lob (arcs over trees), splash damage.</li>
            <li>Allies near a unit under fire will <b>assist</b> automatically.</li>
          </ul>
        </div>
        <div>
          <h3>Building</h3>
          <ul>
            <li>Use buttons to <b>queue</b> Riflemen/Grenadiers.</li>
            <li>Credits tick in over time.</li>
          </ul>
        </div>
      </div>
      <div style="margin-top:12px;display:flex;gap:8px;justify-content:flex-end">
        <button id="closeHelp">Close</button>
      </div>
    </div>
  </div>

  <div id="wrap"><canvas id="c" width="960" height="600"></canvas></div>

  <div id="overlay">
    <div id="panel">
      <h2 id="result">You win!</h2>
      <p id="stats"></p>
      <button onclick="location.reload()">Play again</button>
    </div>
  </div>

<script>
(() => {
  // -------- Viewport & World sizes --------
  const VIEW_W=960, VIEW_H=600; // canvas size
  const MAP_W=2400, MAP_H=1600; // LARGE map
  const ctx=document.getElementById('c').getContext('2d');
  ctx.canvas.width = VIEW_W; ctx.canvas.height = VIEW_H;

  // Camera (top-left of viewport in world coords)
  const cam = { x: 0, y: 0 };

  // Minimap
  const mini = document.getElementById('minimap');
  const mctx = mini.getContext('2d');
  const MINI_W = mini.width, MINI_H = mini.height;
  const mScaleX = MINI_W / MAP_W, mScaleY = MINI_H / MAP_H;

  // UI elems
  const overlay=document.getElementById('overlay');
  const resultEl=document.getElementById('result');
  const statsEl=document.getElementById('stats');
  const btnSelectAll=document.getElementById('selectAll');
  const btnRestart=document.getElementById('restart');
  const btnBuildRifleman=document.getElementById('buildRifleman');
  const btnBuildGrenadier=document.getElementById('buildGrenadier');
  const terrainBtn=document.getElementById('terrainBtn');
  const terrainFile=document.getElementById('terrainFile');
  const muteBtn=document.getElementById('muteBtn');
  const volumeSlider=document.getElementById('volumeSlider');
  const helpBtn=document.getElementById('helpBtn');
  const helpModal=document.getElementById('helpModal');
  const helpClose=document.getElementById('closeHelp');

  // Selection HUD
  const selCountEl = document.getElementById('selCount');
  const selGridEl  = document.getElementById('selGrid');
  const orderFlash = document.getElementById('orderFlash');
  let orderFlashTimer=null;

  // --- Audio ---
  const bgm = new Audio('assets/skirmish1.mp3'); bgm.loop = true; bgm.volume = parseFloat(volumeSlider.value);
  const deathSoundBase = new Audio('assets/death.mp3'); deathSoundBase.volume = 0.6;
  bgm.play().catch(() => {
    const start = () => { bgm.play().catch(()=>{}); document.removeEventListener('pointerdown', start); };
    document.addEventListener('pointerdown', start, { once: true });
  });
  muteBtn.onclick = () => { bgm.muted = !bgm.muted; muteBtn.textContent = bgm.muted ? "ðŸ”‡" : "ðŸ”Š"; };
  volumeSlider.oninput = (e) => { bgm.volume = parseFloat(e.target.value); };

  // --- Custom cursors (SVG data URIs) ---
  const greenTarget = makeCursor('#27e36a');
  const redTarget   = makeCursor('#ff4d5a');
  const defaultCursor = 'crosshair';
  function makeCursor(color){
    const svg = encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32">
      <circle cx="16" cy="16" r="10" fill="none" stroke="${color}" stroke-width="2"/>
      <line x1="16" y1="1" x2="16" y2="7" stroke="${color}" stroke-width="2"/>
      <line x1="16" y1="25" x2="16" y2="31" stroke="${color}" stroke-width="2"/>
      <line x1="1" y1="16" x2="7" y2="16" stroke="${color}" stroke-width="2"/>
      <line x1="25" y1="16" x2="31" y2="16" stroke="${color}" stroke-width="2"/>
      <circle cx="16" cy="16" r="2" fill="${color}"/>
    </svg>`);
    return `url("data:image/svg+xml,${svg}") 16 16, crosshair`;
  }

  // -------- World --------
  const F={PLAYER:1,ENEMY:2};
  const BUILDING_TYPES = {BARRACKS:'barracks'};
  const VISION_RADIUS=100; // renamed to avoid collisions
  const SEP_RADIUS = 18, SEP_FORCE = 65;

  let world;

  // Offscreen fog canvas (full map)
  const fogCanvas = document.createElement('canvas');
  fogCanvas.width = MAP_W; fogCanvas.height = MAP_H;
  const fogCtx = fogCanvas.getContext('2d');

  // --- Camera panning state ---
  const PAN_SPEED = 520;        // px/sec (keyboard)
  const PAN_SPEED_FAST = 980;   // px/sec when Shift is held
  const EDGE_BAND = 18;         // px from canvas edge to trigger edge-scroll
  let keys = new Set();
  let isPanningDrag = false;    // space+drag or middle-mouse drag
  let dragStartScreen = null;   // screen coords
  let dragStartCam = null;      // camera snapshot at drag begin

  function panBy(dx, dy) {
    cam.x = Math.max(0, Math.min(cam.x + dx, MAP_W - VIEW_W));
    cam.y = Math.max(0, Math.min(cam.y + dy, MAP_H - VIEW_H));
  }
  function centerCamera(cx,cy){
    cam.x = Math.max(0, Math.min(cx - VIEW_W/2, MAP_W - VIEW_W));
    cam.y = Math.max(0, Math.min(cy - VIEW_H/2, MAP_H - VIEW_H));
  }
  function worldToScreen(x,y){ return { x: x - cam.x, y: y - cam.y }; }
  function screenToWorld(x,y){ return { x: x + cam.x, y: y + cam.y }; }

  // Minimap interaction
  mini.addEventListener('pointerdown', (e)=>{
    const r=mini.getBoundingClientRect();
    const mx = (e.clientX - r.left), my = (e.clientY - r.top);
    const wx = Math.max(0, Math.min(mx / mScaleX, MAP_W));
    const wy = Math.max(0, Math.min(my / mScaleY, MAP_H));
    centerCamera(wx, wy);
  });

  // Help modal (show on first load and on button)
  const firstRunKey = 'skirmish_help_seen_v1';
  function showHelp(){ helpModal.style.display='flex'; }
  function hideHelp(){ helpModal.style.display='none'; localStorage.setItem(firstRunKey,'1'); }
  if(!localStorage.getItem(firstRunKey)) showHelp();
  helpBtn.onclick = showHelp;
  helpClose.onclick = hideHelp;
  helpModal.addEventListener('click', (e)=>{ if(e.target===helpModal) hideHelp(); });

  // Default ground tiling with graceful fallback
  let groundPattern=null;
  const groundImg = new Image();
  groundImg.crossOrigin = "anonymous";
  groundImg.onload = ()=>{ groundPattern = ctx.createPattern(groundImg,'repeat'); };
  groundImg.onerror = ()=>{
    // Fallback: generate a tiny canvas pattern so the game still looks ok
    const tile = document.createElement('canvas');
    tile.width = 64; tile.height = 64;
    const tctx = tile.getContext('2d');
    tctx.fillStyle = '#3b5d2f'; tctx.fillRect(0,0,64,64);
    tctx.fillStyle = '#466d38';
    for (let y=0; y<64; y+=8){
      for (let x= (y%16===0?0:8); x<64; x+=16){
        tctx.fillRect(x, y, 8, 8);
      }
    }
    groundPattern = ctx.createPattern(tile, 'repeat');
  };
  groundImg.src = 'assets/grass_tile.jpg'; // if this 404s, onerror will kick in

  function reset(){
    // init fog (completely black)
    fogCtx.globalCompositeOperation = 'source-over';
    fogCtx.fillStyle = 'rgba(0,0,0,1)';
    fogCtx.fillRect(0,0,MAP_W,MAP_H);

    world={
      tAccum:0, time:0, score:0,
      units:[], bullets:[], trees:[], buildings:[],
      selection:new Set(), selBox:null,
      ended:false, stats:{lost:0,kills:0,timeStart:performance.now()},
      resources:{credits:500},
      terrainImg:null, clickFx:[],
      grass: Array.from({length:180},()=>({x:Math.random()*MAP_W,y:Math.random()*MAP_H,r:30+Math.random()*70,a:0.06+Math.random()*0.09})),
      terrain: Array.from({length:50},()=>({x:Math.random()*MAP_W,y:Math.random()*MAP_H,r:20+Math.random()*40,color:Math.random()<.5?'#4a3d2a':'#6b6b6b'})),
    };

    // Forests spread across the map
    forest(260,220,20,120); forest(520,820,26,140); forest(1200,380,24,120);
    forest(1700,640,28,160); forest(2000,1200,30,170); forest(1400,1100,22,130);

    // Player barracks (build queue)
    world.buildings.push({
      type:BUILDING_TYPES.BARRACKS, f:F.PLAYER, x:120, y:MAP_H-130, w:70, h:46,
      hp:260, max:260, queue:[], current:null, timeLeft:0
    });

    // Player squad near base
    for(let i=0;i<6;i++){ const u=spawn(200+(i%3)*22,MAP_H-120+Math.floor(i/3)*26,F.PLAYER,'rifleman'); u.selected=true; world.selection.add(u); }
    for(let i=0;i<2;i++){ const u=spawn(280+(i*22),MAP_H-120,F.PLAYER,'grenadier'); u.selected=true; world.selection.add(u); }
    updateSelectionHUD();

    // Enemies elsewhere
    for(let i=0;i<8;i++) spawn(1800+(i%4)*26,320+Math.floor(i/4)*26,F.ENEMY,'rifleman');
    for(let i=0;i<3;i++) spawn(1950+(i*26),420,F.ENEMY,'grenadier');
    for(let i=0;i<6;i++) spawn(2100+(i%3)*26,900+Math.floor(i/3)*26,F.ENEMY,'rifleman');

    // Start camera near player base (center on it)
    centerCamera(260, MAP_H-120);

    // Reveal initial area around starting units
    for(const u of world.units){ if(u.f===F.PLAYER) revealAround(u.x,u.y); }
  }

  function forest(cx,cy,count,spread){
    for(let i=0;i<count;i++){
      const a=Math.random()*Math.PI*2,d=(Math.random()**0.8)*spread;
      const x=cx+Math.cos(a)*d,y=cy+Math.sin(a)*d,r=8+Math.random()*10;
      world.trees.push({x,y,r});
    }
  }

  function spawn(x,y,f,unitType='rifleman'){
    const base = {
      rifleman:  {hp:48,max:48,range:115,dmg:9,  s:1.7},
      grenadier: {hp:60,max:60,range:220,dmg:25, s:1.4} // long-range lobber
    }[unitType];
    const u={
      id:Math.random().toString(36).slice(2),
      type:'unit', f, x, y, r:8,
      hp:base.hp, max:base.max, range:base.range, dmg:base.dmg, s:base.s,
      cd:0, unitType,
      target:null, vx:0, vy:0, facing:0, walk:0,
      selected:false, wander:Math.random()*6.28
    };
    world.units.push(u); return u;
  }

  // --- Input (pointer) + cursor logic ---
  let pointer={x:0,y:0,down:false,dragStart:null,dragging:false, overEnemy:false};
  const DRAG_THRESH=8;

  const canvas=ctx.canvas;

  // Keyboard pan
  window.addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Space','PageUp','PageDown','Home','End'].includes(e.key)) {
      e.preventDefault();
    }
    keys.add(e.key);
    updateCursorForPanMode();
  });
  window.addEventListener('keyup', (e) => { keys.delete(e.key); updateCursorForPanMode(); });

  function updateCursorForPanMode(){
    const spaceHeld = keys.has(' ') || keys.has('Space');
    if (!isPanningDrag && spaceHeld) canvas.style.cursor = 'grab';
  }

  // Begin drag-to-pan if Space is held or middle mouse pressed
  canvas.addEventListener('pointerdown', (e) => {
    const isMiddle = (e.button === 1);
    const spaceHeld = keys.has(' ') || keys.has('Space');
    if (isMiddle || spaceHeld) {
      isPanningDrag = true;
      dragStartScreen = { x: e.clientX, y: e.clientY };
      dragStartCam = { x: cam.x, y: cam.y };
      canvas.style.cursor = 'grabbing';
      world.selBox = null; // prevent selection box while panning
      return;
    }
    // ---- selection start ----
    canvas.setPointerCapture(e.pointerId);
    const p=screenToWorld(...Object.values(pos(e)));
    pointer.x=p.x; pointer.y=p.y; pointer.down=true; pointer.dragStart={x:p.x,y:p.y}; pointer.dragging=false;
    world.selBox={x:p.x,y:p.y,w:0,h:0};
  }, { capture: true });

  canvas.addEventListener('pointermove', (e) => {
    if (isPanningDrag && dragStartScreen) {
      const dx = e.clientX - dragStartScreen.x;
      const dy = e.clientY - dragStartScreen.y;
      panBy(-dx, -dy);
      return;
    }
    const s=pos(e); const p=screenToWorld(s.x,s.y);
    pointer.x=p.x; pointer.y=p.y;
    const hasSelection = world.selection.size>0;
    const spaceHeld = keys.has(' ') || keys.has('Space');
    pointer.overEnemy = !!unitAt(p.x,p.y,F.ENEMY);
    if (!spaceHeld) {
      if (hasSelection && pointer.overEnemy) canvas.style.cursor = redTarget;
      else if (hasSelection) canvas.style.cursor = greenTarget;
      else canvas.style.cursor = defaultCursor;
    }

    if(pointer.down && pointer.dragStart){
      const dx=p.x-pointer.dragStart.x, dy=p.y-pointer.dragStart.y;
      if(!pointer.dragging && (Math.abs(dx)>DRAG_THRESH||Math.abs(dy)>DRAG_THRESH)) pointer.dragging=true;
      if(pointer.dragging){
        world.selBox={x:Math.min(pointer.dragStart.x,p.x), y:Math.min(pointer.dragStart.y,p.y),
                      w:Math.abs(dx), h:Math.abs(dy)};
      }
    }
  }, { capture: true });

  canvas.addEventListener('pointerup', (e) => {
    if (isPanningDrag) {
      isPanningDrag = false;
      dragStartScreen = null;
      dragStartCam = null;
      canvas.style.cursor = 'grab';
      return;
    }
    const p=screenToWorld(...Object.values(pos(e))); pointer.down=false;
    const hasSel = world.selection.size>0;
    if(pointer.dragging && world.selBox){
      world.selection.forEach(u=>u.selected=false); world.selection.clear();
      world.units.forEach(u=>{ if(u.f===F.PLAYER && circleInRect(u.x,u.y,u.r,world.selBox)){ u.selected=true; world.selection.add(u);} });
      updateSelectionHUD();
    } else {
      const enemy = unitAt(p.x,p.y,F.ENEMY);
      const friendly = unitAt(p.x,p.y,F.PLAYER);
      if(enemy && hasSel){
        world.selection.forEach(u=>u.target=enemy);
        flashOrder('Attack');
        addClickFx(p.x,p.y,'#ff4d5a');
      }
      else if(friendly){
        world.selection.forEach(u=>u.selected=false); world.selection.clear();
        friendly.selected=true; world.selection.add(friendly);
        updateSelectionHUD();
      }
      else if(hasSel){ // ground move -> formation
        assignFormationMove([...world.selection], p.x, p.y);
        flashOrder('Move');
        addClickFx(p.x,p.y,'#27e36a');
      }
    }
    world.selBox=null; pointer.dragStart=null; pointer.dragging=false;
  }, { capture: true });

  // Optional: Mouse wheel for vertical pan
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY) * 80;
    panBy(0, delta);
  }, { passive: false });

  // Prevent context menu
  canvas.addEventListener('contextmenu', e=>e.preventDefault(), {passive:false});

  function addClickFx(x,y,color){ world.clickFx.push({x,y,color,age:0,life:0.5}); }
  function pos(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left), y:(e.clientY-r.top)}; }

  // --- Buttons / Build Queue ---
  btnSelectAll.onclick=()=>{
    world.selection.forEach(u=>u.selected=false); world.selection.clear();
    world.units.forEach(u=>{ if(u.f===F.PLAYER){ u.selected=true; world.selection.add(u);} });
    updateSelectionHUD();
  };
  btnRestart.onclick=()=>location.reload();
  btnBuildRifleman.onclick=()=>queueBuild('rifleman',50,3);
  btnBuildGrenadier.onclick=()=>queueBuild('grenadier',100,4);

  function queueBuild(kind,cost,time){
    const b = getBarracks(F.PLAYER);
    if(!b || b.hp<=0) return;
    if(world.resources.credits < cost) return;
    world.resources.credits -= cost;
    b.queue.push({kind, time});
    if(!b.current){ startNextInQueue(b); }
  }
  function startNextInQueue(b){
    if(b.queue.length===0){ b.current=null; b.timeLeft=0; return; }
    b.current = b.queue.shift(); b.timeLeft = b.current.time;
  }
  function getBarracks(faction){
    return world.buildings.find(b => b.f===faction && b.type===BUILDING_TYPES.BARRACKS);
  }

  // --- Helpers ---
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function unitAt(x,y,filt){ for(const u of world.units){ if(filt && u.f!==filt) continue; if(Math.hypot(x-u.x,y-u.y)<=u.r+3) return u; } return null; }
  function circleInRect(cx,cy,r,rect){ const rx=clamp(cx,rect.x,rect.x+rect.w), ry=clamp(cy,rect.y,rect.y+rect.h);
    return (cx-r<=rect.x+rect.w && cx+r>=rect.x && cy-r<=rect.y+rect.h && cy+r>=rect.y && ((cx-rx)**2+(cy-ry)**2)<=r*r); }
  function blocked(ax,ay,bx,by){
    // line-of-sight blocked by trees (for rifles only)
    for(const t of world.trees){
      const dx=bx-ax, dy=by-ay, L2=dx*dx+dy*dy||1, u=clamp(((t.x-ax)*dx+(t.y-ay)*dy)/L2,0,1);
      const px=ax+u*dx, py=ay+u*dy, d2=(px-t.x)**2+(py-t.y)**2;
      if(d2 <= (t.r+3)*(t.r+3)) return true;
    } return false;
  }

  // --- Fog of War (permanent reveal) ---
  function revealAround(x,y){
    fogCtx.save();
    fogCtx.globalCompositeOperation = 'destination-out';
    const g = fogCtx.createRadialGradient(x,y,0,x,y,VISION_RADIUS);
    g.addColorStop(0,'rgba(0,0,0,0.9)');
    g.addColorStop(1,'rgba(0,0,0,0)');
    fogCtx.fillStyle = g;
    fogCtx.beginPath(); fogCtx.arc(x,y,VISION_RADIUS,0,Math.PI*2); fogCtx.fill();
    fogCtx.restore();
  }

  // --- Reactive fire (nearby allies assist) ---
  function reactToAttack(victim, attacker){
    if(!attacker || victim.hp<=0) return;
    victim.target = attacker;
    for(const ally of world.units){
      if(ally===victim) continue;
      if(ally.f!==victim.f || ally.hp<=0) continue;
      const d = Math.hypot(ally.x - victim.x, ally.y - victim.y);
      if(d <= 150 && !blocked(ally.x,ally.y,attacker.x,attacker.y)){
        if(!ally.target || ally.target.dummy) ally.target = attacker;
      }
    }
  }

  // --- Formation assignment ---
  function assignFormationMove(units, tx, ty){
    if(units.length===0) return;
    let cx=0, cy=0; for(const u of units){ cx+=u.x; cy+=u.y; } cx/=units.length; cy/=units.length;
    const face = Math.atan2(ty - cy, tx - cx);
    const n = units.length, spacing = 24;
    const cols = Math.ceil(Math.sqrt(n)), rows = Math.ceil(n / cols);
    const offsets=[]; let i=0;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        if(i++>=n) break;
        const ox = (c - (cols-1)/2)*spacing, oy = (r - (rows-1)/2)*spacing;
        const rx =  ox*Math.cos(face) - oy*Math.sin(face);
        const ry =  ox*Math.sin(face) + oy*Math.cos(face);
        offsets.push({x:rx,y:ry});
      }
    }
    i=0; for(const u of units){ const off = offsets[i++] || {x:0,y:0}; u.target = { x: tx + off.x, y: ty + off.y, dummy:true, formation:true }; }
  }

  // --- Separation steering ---
  function separation(u){
    let fx=0, fy=0, count=0;
    for(const v of world.units){
      if(v===u || v.f!==u.f || v.hp<=0) continue;
      const dx=u.x - v.x, dy=u.y - v.y;
      const d=Math.hypot(dx,dy);
      if(d>0 && d<SEP_RADIUS){
        const m=(SEP_RADIUS - d)/SEP_RADIUS;
        fx += (dx/d) * m; fy += (dy/d) * m; count++;
      }
    }
    if(count>0){ fx/=count; fy/=count; }
    return {fx,fy};
  }

  // --- Game Step ---
  function step(dt){
    world.time += dt; world.tAccum += dt;

    // Keyboard pan per frame
    (function panCameraByKeys(){
      let sx = 0, sy = 0;
      const speed = (keys.has('Shift')) ? PAN_SPEED_FAST : PAN_SPEED;
      if (keys.has('ArrowLeft') || keys.has('a') || keys.has('A')) sx -= speed * dt;
      if (keys.has('ArrowRight')|| keys.has('d') || keys.has('D')) sx += speed * dt;
      if (keys.has('ArrowUp')   || keys.has('w') || keys.has('W')) sy -= speed * dt;
      if (keys.has('ArrowDown') || keys.has('s') || keys.has('S')) sy += speed * dt;
      if (sx || sy) panBy(sx, sy);
    })();

    // Edge scroll
    (function edgeScroll(){
      if (isPanningDrag) return;
      // pointer.x/y are world coords; convert to screen
      const screenX = pointer.x - cam.x;
      const screenY = pointer.y - cam.y;
      let ex = 0, ey = 0;
      if (screenX <= EDGE_BAND) ex = -1;
      else if (screenX >= VIEW_W - EDGE_BAND) ex = 1;
      if (screenY <= EDGE_BAND) ey = -1;
      else if (screenY >= VIEW_H - EDGE_BAND) ey = 1;
      if (ex || ey) {
        const speed = PAN_SPEED * 0.8;
        panBy(ex * speed * dt, ey * speed * dt);
      }
    })();

    if(world.tAccum>=2){ world.resources.credits+=10; world.tAccum=0; }

    // Cooldowns + walk anim + reveal around player units
    for(const u of world.units){
      if(u.cd>0) u.cd-=dt;
      if(u.f===F.PLAYER && u.hp>0) revealAround(u.x,u.y);
      const speed = Math.hypot(u.vx,u.vy);
      if(speed>0.01){ u.facing = Math.atan2(u.vy,u.vx); u.walk += dt * (4 + speed*4); }
      else { u.walk += dt*2; }
    }

    // Enemy seek
    for(const u of world.units){
      if(u.f!==F.ENEMY || u.hp<=0) continue;
      if(!u.target || (u.target.hp!==undefined && u.target.hp<=0)){
        let best=null,bd2=Infinity;
        for(const p of world.units){ if(p.f!==F.PLAYER||p.hp<=0) continue;
          const d2=(p.x-u.x)**2+(p.y-u.y)**2;
          if(d2<bd2 && Math.sqrt(d2)<190 && !blocked(u.x,u.y,p.x,p.y)){ bd2=d2; best=p; } }
        if(best) u.target=best; else { u.wander += (Math.random()-0.5)*0.2; u.x += Math.cos(u.wander)*0.6*60*dt; u.y += Math.sin(u.wander)*0.6*60*dt; }
      }
    }

    // Move & fire
    for(const u of world.units){
      if(u.hp<=0) continue;
      let t=u.target; if(t && t.hp!==undefined && t.hp<=0) t=u.target=null;

      if(t){
        const tx=t.x, ty=t.y, dist=Math.hypot(tx-u.x,ty-u.y);
        const inRange=dist<=u.range;
        const canShoot = inRange && (u.unitType==='grenadier' ? true : !blocked(u.x,u.y,tx,ty));
        if(t.dummy){
          moveToward(u,tx,ty,dt,true);
          if(dist<6) u.target=null;
        } else if(canShoot){
          if(u.cd<=0){ fire(u,t); u.cd=0.5+Math.random()*0.2; }
        } else {
          moveToward(u,tx,ty,dt,true);
        }
      } else {
        const sep = separation(u);
        u.vx = (u.vx + (sep.fx*SEP_FORCE/60))*0.9;
        u.vy = (u.vy + (sep.fy*SEP_FORCE/60))*0.9;
        u.x+=u.vx*60*dt; u.y+=u.vy*60*dt;
      }

      // tree push-out
      for(const tr of world.trees){
        const dx=u.x-tr.x, dy=u.y-tr.y, d=Math.hypot(dx,dy);
        if(d<tr.r+u.r){ const push=(tr.r+u.r-d)+0.1, nx=dx/(d||1), ny=dy/(d||1); u.x+=nx*push; u.y+=ny*push; }
      }
      u.x=clamp(u.x,8,MAP_W-8); u.y=clamp(u.y,8,MAP_H-8);
    }

    // Projectiles
    for(let i=world.bullets.length-1;i>=0;i--){
      const b=world.bullets[i];
      if(b.ballistic){
        b.t += dt;
        const k = Math.min(1, b.t / b.tMax);
        const x = b.ox + (b.tx - b.ox) * k;
        const y = b.oy + (b.ty - b.oy) * k;
        const dist = Math.hypot(b.tx - b.ox, b.ty - b.oy);
        const h = Math.min(90, 18 + dist*0.18);
        const yArc = y - (4 * h * k * (1 - k));
        b.x = x; b.y = yArc;
        if(k >= 1){ explode(b.x,b.y,b.blastRadius,b.dmg,b.f,b.from); world.bullets.splice(i,1); continue; }
      } else {
        const ang=Math.atan2(b.ty-b.y,b.tx-b.x);
        const nx=Math.cos(ang)*b.spd*60*dt, ny=Math.sin(ang)*b.spd*60*dt;
        if(blocked(b.ox,b.oy,b.x+nx,b.y+ny)){ world.bullets.splice(i,1); continue; }
        b.x+=nx; b.y+=ny; b.life-=dt;
        const t=b.target;
        if(t && t.hp>0 && Math.hypot(b.x-t.x,b.y-t.y)<t.r+3){ t.hp -= b.dmg; reactToAttack(t, b.from); world.bullets.splice(i,1); continue; }
        if(b.life<=0){ world.bullets.splice(i,1); }
      }
    }

    // Explosions fade
    if(world.explosions){ for(let i=world.explosions.length-1;i>=0;i--){ const e=world.explosions[i]; e.life-=dt; if(e.life<=0) world.explosions.splice(i,1); } }

    // Barracks production
    const b = getBarracks(F.PLAYER);
    if(b && b.hp>0){
      if(!b.current && b.queue.length>0){ startNextInQueue(b); }
      if(b.current){
        b.timeLeft -= dt;
        if(b.timeLeft<=0){
          const spawnX=b.x+b.w/2+(Math.random()-0.5)*20, spawnY=b.y-10;
          const nu=spawn(spawnX,spawnY,b.f,b.current.kind);
          nu.selected=true; world.selection.add(nu); updateSelectionHUD();
          b.current=null; b.timeLeft=0; startNextInQueue(b);
        }
      }
    }

    // Click FX progress
    for(let i=world.clickFx.length-1;i>=0;i--){
      const f=world.clickFx[i]; f.age+=dt; if(f.age>=f.life) world.clickFx.splice(i,1);
    }

    // Deaths + SFX
    for(let i=world.units.length-1;i>=0;i--){
      const u=world.units[i]; if(u.hp>0) continue;
      const s = deathSoundBase.cloneNode(); s.play().catch(()=>{});
      if(u.selected){ world.selection.delete(u); }
      if(u.f===F.PLAYER) world.stats.lost++; else world.stats.kills++;
      world.units.splice(i,1);
    }
    updateSelectionHUD();

    // Win/lose
    const pAlive=world.units.some(u=>u.f===F.PLAYER), eAlive=world.units.some(u=>u.f===F.ENEMY);
    if(!pAlive||!eAlive) endGame(pAlive && !eAlive);
  }

  function moveToward(u,tx,ty,dt,applySep=false){
    const ang=Math.atan2(ty-u.y,tx-u.x), sp=u.s;
    let vx=Math.cos(ang)*sp, vy=Math.sin(ang)*sp;
    if(applySep){
      const sep = separation(u);
      vx += (sep.fx*SEP_FORCE)/100; vy += (sep.fy*SEP_FORCE)/100;
      const spd=Math.hypot(vx,vy), max=sp*1.25; if(spd>max){ vx*=max/spd; vy*=max/spd; }
    }
    // sidestep trees
    let blockedMove=false;
    for(const tr of world.trees){ const dx=(u.x+vx*60*dt)-tr.x, dy=(u.y+vy*60*dt)-tr.y; if(Math.hypot(dx,dy)<tr.r+u.r){ blockedMove=true; break; } }
    if(blockedMove){ const side=Math.random()<.5?Math.PI/2:-Math.PI/2; vx=Math.cos(ang+side)*sp*.85; vy=Math.sin(ang+side)*sp*.85; }
    u.vx=vx; u.vy=vy; u.x+=vx*60*dt; u.y+=vy*60*dt;
  }

  function fire(from,target){
    if(from.unitType==='grenadier'){
      const dist = Math.hypot(target.x - from.x, target.y - from.y);
      const flight = clamp(0.55 + dist / 600, 0.55, 1.2);
      world.bullets.push({
        x:from.x, y:from.y, ox:from.x, oy:from.y,
        tx:target.x, ty:target.y, target,
        dmg:from.dmg, f:from.f, from,
        ballistic:true, t:0, tMax:flight,
        explosive:true, blastRadius:35
      });
    } else {
      world.bullets.push({x:from.x,y:from.y,ox:from.x,oy:from.y,tx:target.x,ty:target.y,target,
                          spd:5.5,dmg:from.dmg,life:.6,f:from.f,from,explosive:false});
    }
  }

  function explode(x,y,radius,dmg,faction,attacker){
    world.explosions = world.explosions || [];
    world.explosions.push({x,y,radius,life:0.3,maxLife:0.3});
    for(const u of world.units){
      if(u.f===faction || u.hp<=0) continue;
      const dist=Math.hypot(u.x-x,u.y-y);
      if(dist<=radius){
        const dd=Math.max(1, dmg*(1-dist/radius)); 
        u.hp-=dd;
        if(attacker) reactToAttack(u, attacker);
      }
    }
  }

  // --- Drawing helpers (camera-aware) ---
  function drawTerrain(){
    // Tiled ground pattern
    if(groundPattern){
      ctx.save();
      ctx.translate(- (cam.x % 256), - (cam.y % 256));
      ctx.fillStyle = groundPattern;
      ctx.fillRect(-256, -256, VIEW_W+512, VIEW_H+512);
      ctx.restore();
    } else {
      ctx.fillStyle='#355a2f'; ctx.fillRect(0,0,VIEW_W,VIEW_H);
    }
    // Variation blobs (within view)
    for(const g of world.grass){ 
      const s=worldToScreen(g.x,g.y); if(s.x<-120||s.y<-120||s.x>VIEW_W+120||s.y>VIEW_H+120) continue;
      ctx.fillStyle=`rgba(84,140,72,${g.a})`; ctx.beginPath(); ctx.arc(s.x,s.y,g.r,0,Math.PI*2); ctx.fill(); 
    }
    for(const t of world.terrain){ 
      const s=worldToScreen(t.x,t.y); if(s.x<-120||s.y<-120||s.x>VIEW_W+120||s.y>VIEW_H+120) continue;
      ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(s.x,s.y,t.r,0,Math.PI*2); ctx.fill(); 
    }
  }

  function drawTrees(){
    for(const t of world.trees){
      const s=worldToScreen(t.x,t.y);
      if(s.x<-t.r-4||s.y<-t.r-4||s.x>VIEW_W+t.r+4||s.y>VIEW_H+t.r+4) continue;
      ctx.fillStyle='rgba(0,0,0,.35)'; ctx.beginPath(); ctx.arc(s.x+2,s.y+2,t.r,0,Math.PI*2); ctx.fill();
      const grad=ctx.createRadialGradient(s.x-2,s.y-2,2,s.x,s.y,t.r);
      grad.addColorStop(0,'#3f7a3f'); grad.addColorStop(1,'#235a29');
      ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(s.x,s.y,t.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#5a3a21'; ctx.beginPath(); ctx.arc(s.x,s.y+t.r*0.6,3,0,Math.PI*2); ctx.fill();
    }
  }

  function drawBarracks(b){
    const isPlayer = b.f===F.PLAYER;
    const s=worldToScreen(b.x,b.y);
    const x=s.x, y=s.y, w=b.w, h=b.h;

    if(x<-w||y<-h||x>VIEW_W||y>VIEW_H) return;

    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(x+3,y+3,w,h);
    ctx.fillStyle = isPlayer ? '#4a8bd3' : '#d34a4a';
    roundRect(x,y,w,h,6,true,false);
    ctx.fillStyle = isPlayer ? '#2d4a6b' : '#6b2d2d';
    roundRect(x+4,y+4,w-8,14,4,true,false);
    ctx.fillStyle = 'rgba(255,255,255,.15)';
    ctx.fillRect(x+8,y+6,12,3);
    ctx.fillRect(x+w-20,y+6,12,3);
    ctx.fillStyle = '#0e121d';
    ctx.fillRect(x+w/2-6,y+h-16,12,16);
    ctx.fillStyle = isPlayer ? '#3bd1ff' : '#ff6666';
    ctx.fillRect(x+6,y-8,2,8);
    ctx.beginPath(); ctx.moveTo(x+8,y-8); ctx.lineTo(x+22,y-3); ctx.lineTo(x+8,y+2); ctx.closePath(); ctx.fill();

    // HP bar
    ctx.fillStyle='#0e121d'; ctx.fillRect(x,y-10,w,4);
    ctx.fillStyle='#36d399'; ctx.fillRect(x,y-10,w*(b.hp/b.max),4);

    // Production
    if(b.current){
      const total = b.current.time; const prog = Math.max(0,1 - b.timeLeft/total);
      ctx.fillStyle='#36d399'; ctx.fillRect(x,y-16,w*prog,4);
    }
    if(b.queue.length>0){
      ctx.fillStyle='#ffffff'; ctx.font='12px system-ui';
      ctx.fillText(`Queue: ${b.queue.length}`, x, y-20);
    }
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
    if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }

  function drawBuildings(){
    for(const b of world.buildings){ drawBarracks(b); }
  }

  // Animated soldier (camera-aware)
  function drawSoldier(u){
    const s=worldToScreen(u.x,u.y);
    if(s.x<-30||s.y<-30||s.x>VIEW_W+30||s.y>VIEW_H+30) return;

    const dir = u.facing;
    ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(dir);

    ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.ellipse(2,3,u.r*0.9,u.r*0.6,0,0,Math.PI*2); ctx.fill();

    const swing = Math.sin(u.walk)*3.2, backSwing = -Math.sin(u.walk)*3.2;
    ctx.strokeStyle = '#1c2535'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(-2,4); ctx.lineTo(-2,4+swing); ctx.stroke();
    ctx.beginPath(); ctx.moveTo( 2,4); ctx.lineTo( 2,4+backSwing); ctx.stroke();

    const bodyColor = (u.f===F.PLAYER)?'#4a6b8a':'#8a4a4a';
    ctx.fillStyle=bodyColor; ctx.fillRect(-3,-2,6,8);

    ctx.fillStyle='#f4c2a1'; ctx.fillRect(-2.2,-6,4.4,3);
    ctx.fillStyle=(u.f===F.PLAYER)?'#2d4a6b':'#6b2d2d'; ctx.fillRect(-3,-7,6,2);

    ctx.fillStyle='#303030';
    if(u.unitType==='grenadier'){ ctx.fillRect(4,-1,6,2); ctx.fillRect(10,-2,2,4); }
    else { ctx.fillRect(3,-1,7,1.5); ctx.fillRect(10,-2,1.5,3); }

    if(u.selected){ ctx.strokeStyle='#d7f5ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,u.r+3,0,Math.PI*2); ctx.stroke(); }
    ctx.restore();

    // HP bar
    ctx.fillStyle='#0e121d'; ctx.fillRect(s.x-10,s.y-16,20,4);
    ctx.fillStyle='#36d399'; ctx.fillRect(s.x-10,s.y-16,20*(u.hp/u.max),4);
  }

  function drawBulletsExplosions(){
    for(const b of world.bullets){
      const s=worldToScreen(b.x,b.y);
      if(b.ballistic){
        ctx.fillStyle='#f0e06b'; ctx.beginPath(); ctx.arc(s.x,s.y,3,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(240,224,107,.25)'; ctx.beginPath(); ctx.arc(s.x,s.y+3,2,0,Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle='#f8f1b8'; ctx.fillRect(s.x-2,s.y-2,4,4);
      }
    }
    if(world.explosions){
      for(const e of world.explosions){
        const s=worldToScreen(e.x,e.y);
        const a=e.life/e.maxLife, sz=e.radius*(1-a);
        const g=ctx.createRadialGradient(s.x,s.y,0,s.x,s.y,sz);
        g.addColorStop(0,`rgba(255,120,0,${a*.8})`);
        g.addColorStop(.6,`rgba(255,200,0,${a*.35})`);
        g.addColorStop(1,`rgba(255,120,0,0)`);
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s.x,s.y,sz,0,Math.PI*2); ctx.fill();
      }
    }
  }

  function drawClickFx(){
    for(const f of world.clickFx){
      const k=f.age/f.life, r=8+40*k, a=1-k;
      const s=worldToScreen(f.x,f.y);
      ctx.strokeStyle=f.color; ctx.lineWidth=2*a;
      ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x-6,s.y); ctx.lineTo(s.x-2,s.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x+2,s.y); ctx.lineTo(s.x+6,s.y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x,s.y-6); ctx.lineTo(s.x,s.y-2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x,s.y+2); ctx.lineTo(s.x,s.y+6); ctx.stroke();
    }
  }

  // --- Selection HUD ---
  function updateSelectionHUD(){
    const arr = [...world.selection].filter(u=>u.hp>0);
    selCountEl.textContent = arr.length.toString();
    selGridEl.innerHTML = '';
    for(const u of arr){
      const tile = document.createElement('div');
      tile.className = 'tile ' + (u.unitType==='grenadier' ? 'gren' : 'rifle');
      tile.title = `${u.unitType} â€¢ HP ${Math.max(0,Math.ceil(u.hp))}/${u.max}`;
      tile.textContent = u.unitType==='grenadier' ? 'G' : 'R';
      const hpWrap = document.createElement('div'); hpWrap.className = 'hpbar';
      const hpFill = document.createElement('span'); hpFill.style.width = `${Math.max(0, (u.hp/u.max)*100)}%`;
      hpWrap.appendChild(hpFill); tile.appendChild(hpWrap); selGridEl.appendChild(tile);
    }
  }
  function flashOrder(text){
    orderFlash.textContent = `Order: ${text}`;
    orderFlash.classList.add('show');
    if(orderFlashTimer) clearTimeout(orderFlashTimer);
    orderFlashTimer = setTimeout(()=>orderFlash.classList.remove('show'), 700);
  }

  // --- Fog draw (overlay current viewport) ---
  function drawFog(){
    ctx.drawImage(fogCanvas, cam.x, cam.y, VIEW_W, VIEW_H, 0, 0, VIEW_W, VIEW_H);
  }

  // --- Minimap draw ---
  function drawMinimap(){
    mctx.fillStyle = '#203046'; mctx.fillRect(0,0,MINI_W,MINI_H);
    try{
      const temp = document.createElement('canvas'); temp.width=MINI_W; temp.height=MINI_H;
      const tctx=temp.getContext('2d');
      tctx.drawImage(fogCanvas, 0,0,MAP_W,MAP_H, 0,0,MINI_W,MINI_H);
      mctx.drawImage(temp,0,0);
      mctx.strokeStyle = '#8ab4ff'; mctx.lineWidth = 1;
      const rx = cam.x * mScaleX, ry = cam.y * mScaleY, rw = VIEW_W * mScaleX, rh = VIEW_H * mScaleY;
      mctx.strokeRect(rx, ry, rw, rh);
    }catch(_e){
      mctx.strokeStyle = '#8ab4ff'; mctx.strokeRect(cam.x*mScaleX, cam.y*mScaleY, VIEW_W*mScaleX, VIEW_H*mScaleY);
    }
    for(const u of world.units){
      mctx.fillStyle = (u.f===F.PLAYER)?'#3bd1ff':'#ff6666';
      mctx.fillRect((u.x*mScaleX)|0, (u.y*mScaleY)|0, 2, 2);
    }
  }

  // --- Render ---
  function draw(){
    drawTerrain();
    drawTrees();
    drawBuildings();

    // Units: enemy only visible if within vision of any player unit
    for(const u of world.units){
      if(u.f===F.PLAYER) { drawSoldier(u); }
      else {
        let visible=false;
        for(const p of world.units){
          if(p.f!==F.PLAYER || p.hp<=0) continue;
          if(Math.hypot(u.x-p.x,u.y-p.y) <= VISION_RADIUS){ visible=true; break; }
        }
        if(visible) drawSoldier(u);
      }
    }

    drawBulletsExplosions();
    drawClickFx();

    // Selection box (camera aware)
    if(world.selBox){ 
      const s=world.selBox; const a=worldToScreen(s.x,s.y);
      ctx.setLineDash([6,4]); ctx.strokeStyle='#8ab4ff'; ctx.strokeRect(a.x, a.y, s.w, s.h); ctx.setLineDash([]); 
    }

    // Fog overlay LAST
    drawFog();

    // HUD text
    ctx.fillStyle='#ffffff'; ctx.font='bold 14px system-ui';
    const p=world.units.filter(u=>u.f===F.PLAYER).length, e=world.units.filter(u=>u.f===F.ENEMY).length;
    ctx.fillText(`Credits: ${world.resources.credits}  |  Troops: ${p}  |  Hostiles: ${e}`,10,20);
    const b = getBarracks(F.PLAYER);
    if(b){
      if(b.current){
        const prog = Math.max(0,1 - b.timeLeft/b.current.time);
        ctx.fillText(`Barracks: ${b.current.kind} ${Math.round(prog*100)}% â€¢ Queue ${b.queue.length}`, 10, 40);
      } else {
        ctx.fillText(`Barracks: idle â€¢ Queue ${b.queue.length}`, 10, 40);
      }
    }

    // Minimap
    drawMinimap();
  }

  // --- Loop & end ---
  let last=performance.now();
  function loop(now){
    if(world.ended) return;
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    step(dt); draw(); requestAnimationFrame(loop);
  }
  function endGame(win){
    world.ended=true; overlay.style.display='flex';
    resultEl.textContent = win ? 'Victory â€” area secured!' : 'Defeat â€” squad wiped.';
    const sec=((performance.now()-world.stats.timeStart)/1000).toFixed(1);
    statsEl.textContent=`Time: ${sec}s â€¢ Lost: ${world.stats.lost} â€¢ Kills: ${world.stats.kills}`;
  }

  // Drag/drop + button to set terrain image (used to tile-cover the map if desired)
  terrainBtn.onclick = () => terrainFile.click();
  terrainFile.onchange = (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    const img = new Image(); img.onload = ()=>{
      // Build a big tiled canvas from the image, full MAP size
      const tc=document.createElement('canvas'); tc.width=MAP_W; tc.height=MAP_H;
      const tctx=tc.getContext('2d');
      const pat = tctx.createPattern(img,'repeat');
      if(pat){ tctx.fillStyle=pat; tctx.fillRect(0,0,MAP_W,MAP_H); }
      else { tctx.drawImage(img, 0,0,MAP_W,MAP_H); }
      // Replace ground pattern with this baked texture
      groundPattern = ctx.createPattern(tc, 'no-repeat');
    };
    img.src = URL.createObjectURL(file);
  };
  ;['dragenter','dragover'].forEach(ev=>ctx.canvas.addEventListener(ev, e=>{ e.preventDefault(); }));
  ctx.canvas.addEventListener('drop', e=>{
    e.preventDefault();
    const file = e.dataTransfer.files?.[0]; if(!file || !file.type.startsWith('image/')) return;
    const img = new Image(); img.onload = ()=>{
      const tc=document.createElement('canvas'); tc.width=MAP_W; tc.height=MAP_H;
      const tctx=tc.getContext('2d');
      const pat = tctx.createPattern(img,'repeat');
      if(pat){ tctx.fillStyle=pat; tctx.fillRect(0,0,MAP_W,MAP_H); }
      else { tctx.drawImage(img, 0,0,MAP_W,MAP_H); }
      groundPattern = ctx.createPattern(tc, 'no-repeat');
    };
    img.src = URL.createObjectURL(file);
  });

  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
