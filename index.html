<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Army Skirmish — Touch RTS</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0e16;color:#e6e8ef;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #ui{position:fixed;left:0;right:0;top:0;padding:8px 12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;
        background:linear-gradient(180deg,rgba(11,14,22,.9),rgba(11,14,22,0)) ;font-size:14px;z-index:2}
    .pill{background:#121827;border:1px solid #1e2639;padding:6px 10px;border-radius:999px}
    #wrap{height:100%;display:grid;place-items:center}
    canvas{touch-action:none;border:1px solid #1e2639;border-radius:12px;background:#0f1424;
           box-shadow:0 10px 30px rgba(0,0,0,.35)}
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(5,8,16,.65);z-index:3}
    #panel{background:#0f1424;border:1px solid #1e2639;padding:24px;border-radius:16px;text-align:center;max-width:520px}
    button{background:#1b2a4a;border:1px solid #2a3b65;color:#e6e8ef;padding:10px 14px;border-radius:10px;cursor:pointer}
    #btns{margin-left:auto;display:flex;gap:8px}
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill"><b>Army Skirmish</b> — tap ground to move, tap enemy to attack</div>
    <div class="pill">Drag to box-select • Trees block shots • Grenadiers have explosive attacks • Fog of war active</div>
    <div id="btns">
      <button id="buildRifleman">Build Rifleman (50)</button>
      <button id="buildGrenadier">Build Grenadier (100)</button>
      <button id="selectAll">Select all</button>
      <button id="restart">Restart</button>
    </div>
  </div>
  <div id="wrap"><canvas id="c" width="960" height="600"></canvas></div>

  <div id="overlay">
    <div id="panel">
      <h2 id="result">You win!</h2>
      <p id="stats"></p>
      <button onclick="location.reload()">Play again</button>
    </div>
  </div>

<script>
(() => {
  const W=960,H=600;
  const ctx=document.getElementById('c').getContext('2d');
  const overlay=document.getElementById('overlay');
  const resultEl=document.getElementById('result');
  const statsEl=document.getElementById('stats');
  const btnSelectAll=document.getElementById('selectAll');
  const btnRestart=document.getElementById('restart');
  const btnBuildRifleman=document.getElementById('buildRifleman');
  const btnBuildGrenadier=document.getElementById('buildGrenadier');
  const canvas=ctx.canvas;

  // -------- World --------
  let world;
  const F={PLAYER:1,ENEMY:2};
  const BUILDING_TYPES = {BASE: 'base', BARRACKS: 'barracks'};
  function reset(){
    world={
      t:0, units:[], bullets:[], trees:[], buildings:[], selection:new Set(), selBox:null,
      ended:false, stats:{lost:0,kills:0,timeStart:performance.now()},
      fogOfWar:null, revealed:new Set(), resources: {credits: 500}
    };
    // Initialize fog of war
    world.fogOfWar = document.createElement('canvas');
    world.fogOfWar.width = W;
    world.fogOfWar.height = H;
    const fogCtx = world.fogOfWar.getContext('2d');
    fogCtx.fillStyle = '#000000';
    fogCtx.fillRect(0, 0, W, H);
    // simple grassy terrain blobs
    world.grass=Array.from({length:160},()=>({x:Math.random()*W,y:Math.random()*H,r:30+Math.random()*80,a:0.06+Math.random()*0.08}));
    // Add some colorful terrain features
    world.terrain=Array.from({length:30},()=>({
      x:Math.random()*W, y:Math.random()*H, r:20+Math.random()*40,
      type:Math.random()<0.5?'dirt':'rock', color:Math.random()<0.5?'#4a3d2a':'#5a5a5a'
    }));
    // forests
    forest(260,220,16,90); forest(520,420,20,100); forest(740,180,18,85);
    // player base
    world.buildings.push({type:BUILDING_TYPES.BASE, f:F.PLAYER, x:80, y:480, w:40, h:30, hp:200, max:200, production:null, productionTime:0});
    
    // player squad (6 riflemen + 2 grenadiers)
    for(let i=0;i<6;i++){ const u=spawn(120+(i%3)*22,440+Math.floor(i/3)*26,F.PLAYER,'rifleman'); u.selected=true; world.selection.add(u); }
    for(let i=0;i<2;i++){ const u=spawn(200+(i*22),440,F.PLAYER,'grenadier'); u.selected=true; world.selection.add(u); }
    // enemy squads (6 riflemen + 2 grenadiers)
    for(let i=0;i<6;i++) spawn(760+(i%3)*24,160+Math.floor(i/3)*24,F.ENEMY,'rifleman');
    for(let i=0;i<2;i++) spawn(760+(i*24),220,F.ENEMY,'grenadier');
    for(let i=0;i<4;i++) spawn(820+(i%2)*24,320+Math.floor(i/2)*24,F.ENEMY,'rifleman');
  }
  function forest(cx,cy,count,spread){
    for(let i=0;i<count;i++){
      const a=Math.random()*Math.PI*2,d=(Math.random()**0.8)*spread;
      const x=cx+Math.cos(a)*d,y=cy+Math.sin(a)*d,r=8+Math.random()*10;
      world.trees.push({x,y,r});
    }
  }
  function spawn(x,y,f,unitType='rifleman'){
    const baseStats = {
      rifleman: {hp:48,max:48,range:115,dmg:9,speed:1.7},
      grenadier: {hp:60,max:60,range:90,dmg:25,speed:1.4}
    };
    const stats = baseStats[unitType] || baseStats.rifleman;
    const u={
      type:'unit',f,x,y,vx:0,vy:0,r:8,s:stats.speed,hp:stats.hp,max:stats.max,
      range:stats.range,cd:0,dmg:stats.dmg,selected:false,wander:Math.random()*6.28,
      target:null,unitType:unitType
    };
    world.units.push(u);return u;
  }

  // -------- Input (mouse + touch via Pointer Events) --------
  let pointer={x:0,y:0,down:false,dragStart:null,dragging:false};
  const DRAG_THRESH=8;
  canvas.addEventListener('pointerdown',e=>{
    canvas.setPointerCapture(e.pointerId);
    const p=pos(e); pointer.x=p.x; pointer.y=p.y; pointer.down=true; pointer.dragStart={x:p.x,y:p.y}; pointer.dragging=false;
    world.selBox={x:p.x,y:p.y,w:0,h:0};
  });
  canvas.addEventListener('pointermove',e=>{
    const p=pos(e); pointer.x=p.x; pointer.y=p.y;
    if(pointer.down && pointer.dragStart){
      const dx=p.x-pointer.dragStart.x, dy=p.y-pointer.dragStart.y;
      if(!pointer.dragging && (Math.abs(dx)>DRAG_THRESH||Math.abs(dy)>DRAG_THRESH)) pointer.dragging=true;
      if(pointer.dragging){
        world.selBox={x:Math.min(pointer.dragStart.x,p.x), y:Math.min(pointer.dragStart.y,p.y),
                      w:Math.abs(dx), h:Math.abs(dy)};
      }
    }
  });
  canvas.addEventListener('pointerup',e=>{
    const p=pos(e); pointer.down=false;
    if(pointer.dragging && world.selBox){
      // finish box-select
      world.selection.forEach(u=>u.selected=false); world.selection.clear();
      world.units.forEach(u=>{ if(u.f===F.PLAYER && circleInRect(u.x,u.y,u.r,world.selBox)){ u.selected=true; world.selection.add(u);} });
    } else {
      // tap logic
      const enemy = unitAt(p.x,p.y,F.ENEMY);
      const friendly = unitAt(p.x,p.y,F.PLAYER);
      if(enemy && world.selection.size){ world.selection.forEach(u=>u.target=enemy); }
      else if(friendly){ world.selection.forEach(u=>u.selected=false); world.selection.clear(); friendly.selected=true; world.selection.add(friendly); }
      else { // ground tap -> move
        world.selection.forEach(u=>u.target={x:p.x,y:p.y,dummy:true});
      }
    }
    world.selBox=null; pointer.dragStart=null; pointer.dragging=false;
  });
  canvas.addEventListener('contextmenu', e=>e.preventDefault(), {passive:false});
  function pos(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left), y:(e.clientY-r.top)}; }

  btnSelectAll.onclick=()=>{
    world.selection.forEach(u=>u.selected=false); world.selection.clear();
    world.units.forEach(u=>{ if(u.f===F.PLAYER){ u.selected=true; world.selection.add(u);} });
  };
  btnRestart.onclick=()=>location.reload();
  
  btnBuildRifleman.onclick=()=>{
    const base = world.buildings.find(b => b.f === F.PLAYER && b.type === BUILDING_TYPES.BASE && b.hp > 0);
    if(base && !base.production && world.resources.credits >= 50){
      world.resources.credits -= 50;
      base.production = 'rifleman';
      base.productionTime = 3;
    }
  };
  
  btnBuildGrenadier.onclick=()=>{
    const base = world.buildings.find(b => b.f === F.PLAYER && b.type === BUILDING_TYPES.BASE && b.hp > 0);
    if(base && !base.production && world.resources.credits >= 100){
      world.resources.credits -= 100;
      base.production = 'grenadier';
      base.productionTime = 4;
    }
  };

  // -------- Helpers --------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  function unitAt(x,y,filt){ for(const u of world.units){ if(filt && u.f!==filt) continue; if(Math.hypot(x-u.x,y-u.y)<=u.r+3) return u; } return null; }
  function circleInRect(cx,cy,r,rect){ const rx=clamp(cx,rect.x,rect.x+rect.w), ry=clamp(cy,rect.y,rect.y+rect.h);
    return (cx-r<=rect.x+rect.w && cx+r>=rect.x && cy-r<=rect.y+rect.h && cy+r>=rect.y && ((cx-rx)**2+(cy-ry)**2)<=r*r); }
  function blocked(ax,ay,bx,by){ // LoS blocked by trees?
    for(const t of world.trees){
      const dx=bx-ax, dy=by-ay, L2=dx*dx+dy*dy||1, u=clamp(((t.x-ax)*dx+(t.y-ay)*dy)/L2,0,1);
      const px=ax+u*dx, py=ay+u*dy, d2=(px-t.x)**2+(py-t.y)**2;
      if(d2 <= (t.r+3)*(t.r+3)) return true;
    } return false;
  }
  
  function updateFogOfWar(){
    const visionRadius = 80; // How far units can see
    
    // Clear revealed areas around player units
    for(const u of world.units){
      if(u.f === F.PLAYER && u.hp > 0){
        const x = Math.floor(u.x);
        const y = Math.floor(u.y);
        
        // Mark area as revealed
        for(let dx = -visionRadius; dx <= visionRadius; dx += 2){
          for(let dy = -visionRadius; dy <= visionRadius; dy += 2){
            if(dx*dx + dy*dy <= visionRadius*visionRadius){
              const key = `${x+dx},${y+dy}`;
              world.revealed.add(key);
            }
          }
        }
      }
    }
  }
  
  function isRevealed(x, y){
    const key = `${Math.floor(x)},${Math.floor(y)}`;
    return world.revealed.has(key);
  }

  // -------- Game Step --------
  function step(dt){
    // Update fog of war
    updateFogOfWar();
    
    // cooldowns
    world.units.forEach(u=>{ if(u.cd>0) u.cd-=dt; });

    // simple enemy behavior
    for(const u of world.units){
      if(u.f!==F.ENEMY || u.hp<=0) continue;
      if(!u.target || (u.target.hp!==undefined && u.target.hp<=0)){
        // find nearest visible player in radius
        let best=null,bd2=Infinity;
        for(const p of world.units){ if(p.f!==F.PLAYER||p.hp<=0) continue;
          const d2=(p.x-u.x)**2+(p.y-u.y)**2;
          if(d2<bd2 && Math.sqrt(d2)<190 && !blocked(u.x,u.y,p.x,p.y)){ bd2=d2; best=p; } }
        if(best) u.target=best;
        else { // wander idle
          u.wander += (Math.random()-0.5)*0.2;
          u.x += Math.cos(u.wander)*0.6*60*dt; u.y += Math.sin(u.wander)*0.6*60*dt;
        }
      }
    }

    // move/attack
    for(const u of world.units){
      if(u.hp<=0) continue;
      let t=u.target;
      if(t && t.hp!==undefined && t.hp<=0) t=u.target=null;
      if(t){
        const tx=t.x, ty=t.y, dist=Math.hypot(tx-u.x,ty-u.y);
        const inRange=dist<=u.range, canShoot=inRange && !blocked(u.x,u.y,tx,ty);
        if(t.dummy){ moveToward(u,tx,ty,dt); if(dist<6) u.target=null; }
        else if(canShoot){ if(u.cd<=0){ fire(u,t); u.cd=0.5+Math.random()*0.2; } }
        else { moveToward(u,tx,ty,dt); }
      }else{
        u.vx*=0.9; u.vy*=0.9; u.x+=u.vx*60*dt; u.y+=u.vy*60*dt;
      }
      // tree push-out
      for(const tr of world.trees){
        const dx=u.x-tr.x, dy=u.y-tr.y, d=Math.hypot(dx,dy);
        if(d<tr.r+u.r){ const push=(tr.r+u.r-d)+0.1, nx=dx/(d||1), ny=dy/(d||1); u.x+=nx*push; u.y+=ny*push; }
      }
      u.x=clamp(u.x,8,W-8); u.y=clamp(u.y,8,H-8);
    }

    // bullets
    for(let i=world.bullets.length-1;i>=0;i--){
      const b=world.bullets[i], ang=Math.atan2(b.ty-b.y,b.tx-b.x);
      const nx=Math.cos(ang)*b.spd*60*dt, ny=Math.sin(ang)*b.spd*60*dt;
      // early stop if newly blocked
      if(blocked(b.ox,b.oy,b.x+nx,b.y+ny)){ 
        if(b.explosive) explode(b.x,b.y,b.blastRadius,b.dmg,b.f);
        world.bullets.splice(i,1); continue; 
      }
      b.x+=nx; b.y+=ny; b.life-=dt;
      const t=b.target;
      if(t && t.hp>0 && Math.hypot(b.x-t.x,b.y-t.y) < t.r+3){ 
        if(b.explosive) {
          explode(b.x,b.y,b.blastRadius,b.dmg,b.f);
        } else {
          t.hp-=b.dmg;
        }
        world.bullets.splice(i,1); continue; 
      }
      if(b.life<=0) {
        if(b.explosive) explode(b.x,b.y,b.blastRadius,b.dmg,b.f);
        world.bullets.splice(i,1);
      }
    }

    // explosions
    if(world.explosions){
      for(let i=world.explosions.length-1;i>=0;i--){
        const e=world.explosions[i];
        e.life-=dt;
        if(e.life<=0) world.explosions.splice(i,1);
      }
    }
    
    // building production
    for(const b of world.buildings){
      if(b.production && b.hp > 0){
        b.productionTime -= dt;
        if(b.productionTime <= 0){
          // Spawn unit near building
          const spawnX = b.x + b.w/2 + (Math.random()-0.5)*20;
          const spawnY = b.y - 20;
          const newUnit = spawn(spawnX, spawnY, b.f, b.production);
          // Auto-select newly built units
          if(b.f === F.PLAYER){
            newUnit.selected = true;
            world.selection.add(newUnit);
          }
          b.production = null;
          b.productionTime = 0;
        }
      }
    }
    
    // Credit income (every 2 seconds)
    world.t %= 2; // Reset every 2 seconds
    if(world.t < dt){
      world.resources.credits += 10; // 10 credits every 2 seconds
    }

    // deaths + win/lose
    for(let i=world.units.length-1;i>=0;i--){
      const u=world.units[i]; if(u.hp>0) continue;
      if(u.f===F.PLAYER) world.stats.lost++; else world.stats.kills++;
      world.units.splice(i,1);
    }
    const pAlive=world.units.some(u=>u.f===F.PLAYER), eAlive=world.units.some(u=>u.f===F.ENEMY);
    if(!pAlive||!eAlive) endGame(pAlive && !eAlive);
  }
  function moveToward(u,tx,ty,dt){
    const ang=Math.atan2(ty-u.y,tx-u.x), sp=u.s;
    let vx=Math.cos(ang)*sp, vy=Math.sin(ang)*sp;
    // try sidestep if immediate collision
    let blockedMove=false;
    for(const tr of world.trees){ const dx=(u.x+vx*60*dt)-tr.x, dy=(u.y+vy*60*dt)-tr.y; if(Math.hypot(dx,dy)<tr.r+u.r){ blockedMove=true; break; } }
    if(blockedMove){ const side=Math.random()<.5?Math.PI/2:-Math.PI/2; vx=Math.cos(ang+side)*sp*.85; vy=Math.sin(ang+side)*sp*.85; }
    u.vx=vx; u.vy=vy; u.x+=vx*60*dt; u.y+=vy*60*dt;
  }
  function fire(from,target){
    if(from.unitType === 'grenadier') {
      // Grenade with area damage
      world.bullets.push({x:from.x,y:from.y,ox:from.x,oy:from.y,tx:target.x,ty:target.y,target,
                          spd:4.0,dmg:from.dmg,life:1.2, f:from.f, explosive:true, blastRadius:35});
    } else {
      // Regular bullet
      world.bullets.push({x:from.x,y:from.y,ox:from.x,oy:from.y,tx:target.x,ty:target.y,target,
                          spd:5.5,dmg:from.dmg,life:.6, f:from.f, explosive:false});
    }
  }
  
  function explode(x,y,radius,dmg,faction){
    // Add explosion effect
    world.explosions = world.explosions || [];
    world.explosions.push({x,y,radius,life:0.3,maxLife:0.3});
    
    // Damage all units in blast radius
    for(const u of world.units){
      if(u.f === faction || u.hp <= 0) continue; // Don't damage same faction
      const dist = Math.hypot(u.x-x, u.y-y);
      if(dist <= radius){
        const damage = Math.max(1, dmg * (1 - dist/radius)); // Damage falls off with distance
        u.hp -= damage;
      }
    }
  }

  // -------- Sprite System --------
  function createSoldierSprite(faction, unitType = 'rifleman') {
    const size = 16;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');
    
    // Clear background
    ctx.clearRect(0, 0, size, size);
    
    if (unitType === 'rifleman') {
      // Body (main color)
      ctx.fillStyle = faction === F.PLAYER ? '#4a6b8a' : '#8a4a4a';
      ctx.fillRect(6, 8, 4, 6);
      
      // Head
      ctx.fillStyle = '#f4c2a1';
      ctx.fillRect(7, 4, 2, 3);
      
      // Helmet
      ctx.fillStyle = faction === F.PLAYER ? '#2d4a6b' : '#6b2d2d';
      ctx.fillRect(6, 3, 4, 2);
      
      // Arms
      ctx.fillStyle = '#4a6b8a';
      ctx.fillRect(4, 9, 2, 4);
      ctx.fillRect(10, 9, 2, 4);
      
      // Legs
      ctx.fillStyle = '#2d4a6b';
      ctx.fillRect(6, 14, 2, 2);
      ctx.fillRect(8, 14, 2, 2);
      
      // Weapon (rifle)
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(11, 6, 3, 1);
      ctx.fillRect(13, 5, 1, 3);
    } else if (unitType === 'grenadier') {
      // Body (main color)
      ctx.fillStyle = faction === F.PLAYER ? '#4a6b8a' : '#8a4a4a';
      ctx.fillRect(6, 8, 4, 6);
      
      // Head
      ctx.fillStyle = '#f4c2a1';
      ctx.fillRect(7, 4, 2, 3);
      
      // Helmet with visor
      ctx.fillStyle = faction === F.PLAYER ? '#2d4a6b' : '#6b2d2d';
      ctx.fillRect(6, 3, 4, 2);
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(7, 4, 2, 1);
      
      // Arms
      ctx.fillStyle = '#4a6b8a';
      ctx.fillRect(4, 9, 2, 4);
      ctx.fillRect(10, 9, 2, 4);
      
      // Legs
      ctx.fillStyle = '#2d4a6b';
      ctx.fillRect(6, 14, 2, 2);
      ctx.fillRect(8, 14, 2, 2);
      
      // Grenade launcher
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(11, 6, 4, 1);
      ctx.fillRect(14, 5, 1, 3);
      // Grenade
      ctx.fillStyle = '#8a8a2a';
      ctx.fillRect(15, 6, 1, 1);
    }
    
    return canvas;
  }

  // -------- Rendering --------
  function draw(){
    // Base terrain with VERY BRIGHT green color - ALWAYS VISIBLE
    ctx.fillStyle='#8dcb8d'; ctx.fillRect(0,0,W,H);
    
    // Add some brown dirt patches
    for(let i=0;i<20;i++){
      const x=Math.random()*W, y=Math.random()*H, r=40+Math.random()*60;
      ctx.fillStyle='#cbad8a';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    
    // Add grass patches - VERY bright and visible
    for(const g of world.grass){ ctx.fillStyle=`rgba(102,170,90,${g.a*3})`; ctx.beginPath(); ctx.arc(g.x,g.y,g.r,0,Math.PI*2); ctx.fill(); }
    
    // Add terrain features (dirt and rock patches)
    for(const t of world.terrain){
      ctx.fillStyle = t.color;
      ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fill();
    }
    // trees (only in revealed areas)
    for(const t of world.trees){
      if(isRevealed(t.x, t.y)){
        // Tree trunk
        ctx.fillStyle='#8b4513'; ctx.beginPath(); ctx.arc(t.x,t.y+t.r*0.55,3,0,Math.PI*2); ctx.fill();
        // Tree canopy - more vibrant green
        const grad=ctx.createRadialGradient(t.x-2,t.y-2,2,t.x,t.y,t.r); 
        grad.addColorStop(0,'#4a8b4a'); 
        grad.addColorStop(0.7,'#2d6b2d'); 
        grad.addColorStop(1,'#1a4a1a');
        ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fill();
      }
    }
    // buildings (only in revealed areas, except player buildings)
    for(const b of world.buildings){
      if(b.f === F.PLAYER || isRevealed(b.x, b.y)){
        // Building shadow
        ctx.fillStyle='rgba(0,0,0,.4)'; ctx.fillRect(b.x+2,b.y+2,b.w,b.h);
        
        // Building body - more vibrant colors
        ctx.fillStyle = b.f === F.PLAYER ? '#4a8bd3' : '#d34a4a';
        ctx.fillRect(b.x, b.y, b.w, b.h);
        
        // Building details
        ctx.fillStyle = b.f === F.PLAYER ? '#2d4a6b' : '#6b2d2d';
        ctx.fillRect(b.x+2, b.y+2, b.w-4, 4);
        ctx.fillRect(b.x+2, b.y+b.h-6, b.w-4, 4);
        
        // Production indicator
        if(b.production){
          const progress = 1 - (b.productionTime / (b.production === 'rifleman' ? 3 : 4));
          ctx.fillStyle='#36d399';
          ctx.fillRect(b.x, b.y-6, b.w * progress, 4);
        }
        
        // Health bar
        ctx.fillStyle='#0e121d'; ctx.fillRect(b.x, b.y-12, b.w, 4);
        ctx.fillStyle='#36d399'; ctx.fillRect(b.x, b.y-12, b.w*(b.hp/b.max), 4);
      }
    }
    // NO FOG OF WAR ON TERRAIN - terrain is always fully visible
    // Fog of war only affects units and buildings visibility
    
    // units (render AFTER fog of war so they're always visible)
    for(const u of world.units){
      if(u.f === F.PLAYER || isRevealed(u.x, u.y)){
        // Simple colored circles instead of complex sprites
        const unitColor = u.f === F.PLAYER ? '#4a8bd3' : '#d34a4a';
        const unitType = u.unitType || 'rifleman';
        
        // Main unit body
        ctx.fillStyle = unitColor;
        ctx.beginPath();
        ctx.arc(u.x, u.y, u.r, 0, Math.PI * 2);
        ctx.fill();
        
        // Unit type indicator (smaller circle inside)
        ctx.fillStyle = unitType === 'grenadier' ? '#ffaa00' : '#ffffff';
        ctx.beginPath();
        ctx.arc(u.x, u.y, u.r * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        // Selection ring
        if(u.selected){ 
          ctx.strokeStyle='#d7f5ff'; 
          ctx.lineWidth=3; 
          ctx.beginPath(); 
          ctx.arc(u.x,u.y,u.r+3,0,Math.PI*2); 
          ctx.stroke(); 
        }
        
        // hp bar
        ctx.fillStyle='#0e121d'; ctx.fillRect(u.x-10,u.y-16,20,4);
        ctx.fillStyle='#36d399'; ctx.fillRect(u.x-10,u.y-16,20*(u.hp/u.max),4);
      }
    }
    
    // bullets
    for(const b of world.bullets){ ctx.fillStyle='#f8f1b8'; ctx.fillRect(b.x-2,b.y-2,4,4); }
    // explosions
    if(world.explosions){
      for(const e of world.explosions){
        const alpha = e.life / e.maxLife;
        const size = e.radius * alpha;
        const grad = ctx.createRadialGradient(e.x,e.y,0,e.x,e.y,size);
        grad.addColorStop(0,`rgba(255,100,0,${alpha*0.8})`);
        grad.addColorStop(0.5,`rgba(255,200,0,${alpha*0.4})`);
        grad.addColorStop(1,`rgba(255,100,0,0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(e.x,e.y,size,0,Math.PI*2);
        ctx.fill();
      }
    }
    // selection box
    if(world.selBox){ const s=world.selBox; ctx.setLineDash([6,4]); ctx.strokeStyle='#8ab4ff'; ctx.strokeRect(s.x,s.y,s.w,s.h); ctx.setLineDash([]); }
    
    // hud - bigger and whiter text
    ctx.fillStyle='#ffffff'; ctx.font='bold 14px system-ui';
    const p=world.units.filter(u=>u.f===F.PLAYER).length, e=world.units.filter(u=>u.f===F.ENEMY).length;
    ctx.fillText(`Credits: ${world.resources.credits}  |  Troops: ${p}  |  Hostiles: ${e}`,10,20);
    
    // Building production status
    const base = world.buildings.find(b => b.f === F.PLAYER && b.type === BUILDING_TYPES.BASE);
    if(base && base.production){
      const progress = 1 - (base.productionTime / (base.production === 'rifleman' ? 3 : 4));
      ctx.fillText(`Building: ${base.production} (${Math.round(progress*100)}%)`, 10, 40);
    }
    
    // Debug info
    const playerUnits = world.units.filter(u => u.f === F.PLAYER);
    ctx.fillText(`Player units: ${playerUnits.length}`, 10, 60);
    if(playerUnits.length > 0){
      const firstUnit = playerUnits[0];
      ctx.fillText(`First unit at: ${Math.round(firstUnit.x)}, ${Math.round(firstUnit.y)}`, 10, 80);
    }
  }

  // -------- Loop & end --------
  let last=performance.now();
  function loop(now){
    if(world.ended) return;
    const dt=Math.min(0.033,(now-last)/1000); last=now; world.t+=dt;
    step(dt); draw(); requestAnimationFrame(loop);
  }
  function endGame(win){
    world.ended=true; overlay.style.display='flex';
    resultEl.textContent = win ? 'Victory — area secured!' : 'Defeat — squad wiped.';
    const sec=((performance.now()-world.stats.timeStart)/1000).toFixed(1);
    statsEl.textContent=`Time: ${sec}s • Lost: ${world.stats.lost} • Kills: ${world.stats.kills}`;
  }

  reset(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
